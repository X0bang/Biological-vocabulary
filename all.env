main.py中的内容：
from database import init_database, close_database
from word_manager import query_word, view_words, mark_word_status, batch_add_words
from recitation import recitation_mode
from file_reader import read_txt_files, detect_txt_files
from dotenv import load_dotenv

# 加载 .env 文件中的环境变量
load_dotenv()

def main():
    """
    主程序入口，初始化数据库并提供交互式菜单。
    """
    try:
        conn, cursor = init_database()
    except RuntimeError as e:
        print(f"无法启动程序: {e}")
        return
    
    # 启动时检测并读取 .txt 文件
    read_txt_files(conn, cursor)
    
    while True:
        print("\n=== 单词记忆系统 ===")
        print("1. 查询单词")
        print("2. 背诵模式")
        print("3. 查看单词列表")
        print("4. 标记单词状态")
        print("5. 检测单词本文件 (.txt)")
        print("6. 批量输入单词")
        print("7. 退出")
        choice = input("请选择功能 (1-7): ")
        
        if choice == "1":
            word = input("请输入要查询的单词: ").strip()
            if word:
                query_word(word, conn, cursor)
        elif choice == "2":
            recitation_mode(conn, cursor)
        elif choice == "3":
            view_words(cursor)
        elif choice == "4":
            mark_word_status(conn, cursor)
        elif choice == "5":
            detect_txt_files()
        elif choice == "6":
            batch_add_words(conn, cursor)
        elif choice == "7":
            print("感谢使用，再见！")
            close_database(conn)
            break
        else:
            print("无效选择，请重新输入！")

if __name__ == "__main__":
    main()
api.py中的内容：
from openai import OpenAI
import os
from dotenv import load_dotenv

# 加载 .env 文件中的环境变量
load_dotenv()

# 获取 API 密钥和基础 URL，从环境变量读取
api_key = os.getenv("OPENAI_API_KEY")
base_url = os.getenv("OPENAI_BASE_URL")
model = os.getenv("OPENAI_MODEL", "gpt-4o-mini")  # 默认模型为 gpt-4o-mini

# 检查 API 密钥是否提供
if not api_key:
    raise ValueError("未提供 OpenAI API 密钥。请在 .env 文件中设置 OPENAI_API_KEY。")

# 初始化 OpenAI 客户端，支持自定义 base_url
client = OpenAI(api_key=api_key, base_url=base_url)

def fetch_word_info(word):
    """
    使用 OpenAI API 查询单词信息，包括翻译、音标和例句。
    返回包含翻译、音标和例句的字典，若失败则返回 None。
    """
    try:
        # 构建提示词，请求模型提供单词的详细信息
        prompt = f"""
        我正在创建一个生物单词记忆系统，请提供以下关于生物单词 '{word}' 的信息：
        1. 中文翻译（简洁明了）
        2. 音标（国际音标格式，例如 /ˈɛk.səm.pəl/）
        3. 一个简单的英文例句（包含该单词）及其中文翻译
        用以下格式返回信息，确保内容准确且简洁：
        翻译: [中文翻译]
        音标: [音标]
        例句: [英文例句] | [例句中文翻译]
        如果单词无效或无法查询，请返回 '信息不可用'。
        """

        # 调用 OpenAI API
        response = client.chat.completions.create(
            model=model,  # 从环境变量读取模型名称
            messages=[
                {"role": "system", "content": "你是一个专业的英语助手，擅长提供单词的翻译和语言学习信息。"},
                {"role": "user", "content": prompt}
            ],
            max_tokens=150,
            temperature=0.5
        )

        # 解析 API 响应内容
        content = response.choices[0].message.content.strip()
        if "信息不可用" in content:
            print(f"无法获取单词 '{word}' 的信息。")
            return None

        # 提取翻译、音标和例句
        translation = ""
        phonetic = ""
        example = ""
        for line in content.splitlines():
            line = line.strip()
            if line.startswith("翻译:"):
                translation = line.replace("翻译:", "").strip()
            elif line.startswith("音标:"):
                phonetic = line.replace("音标:", "").strip()
            elif line.startswith("例句:"):
                example = line.replace("例句:", "").strip()

        if translation and phonetic and example:
            return {
                'translation': translation,
                'phonetic': phonetic,
                'example': example
            }
        else:
            print(f"解析单词 '{word}' 的信息时出错，返回内容不完整。")
            return None

    except Exception as e:
        print(f"OpenAI API 查询错误: {e}")
        return None
database.py中的内容：
import sqlite3
import os
from dotenv import load_dotenv

# 加载 .env 文件中的环境变量
load_dotenv()

def init_database():
    """
    初始化数据库，创建 words 表（如果不存在）。
    返回数据库连接和游标对象。
    """
    db_path = os.getenv("DB_PATH", "word_database.db")  # 从环境变量获取数据库路径，默认值作为备用
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS words (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                word TEXT UNIQUE NOT NULL,
                translation TEXT,
                phonetic TEXT,
                example TEXT,
                status TEXT DEFAULT '需复习',
                interval INTEGER DEFAULT 0,
                repetitions INTEGER DEFAULT 0,
                easiness_factor REAL DEFAULT 2.5
          )
        ''')

        conn.commit()
        print(f"数据库初始化成功，路径: {db_path}")
        return conn, cursor
    except Exception as e:
        raise RuntimeError(f"数据库初始化失败: {e}")

def close_database(conn):
    """
    关闭数据库连接。
    """
    conn.close()
database.py中的内容：
import sqlite3
import os
from dotenv import load_dotenv

# 加载 .env 文件中的环境变量
load_dotenv()

def init_database():
    """
    初始化数据库，创建 words 表（如果不存在）。
    返回数据库连接和游标对象。
    """
    db_path = os.getenv("DB_PATH", "word_database.db")  # 从环境变量获取数据库路径，默认值作为备用
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS words (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                word TEXT UNIQUE NOT NULL,
                translation TEXT,
                phonetic TEXT,
                example TEXT,
                status TEXT DEFAULT '需复习',
                interval INTEGER DEFAULT 0,
                repetitions INTEGER DEFAULT 0,
                easiness_factor REAL DEFAULT 2.5
          )
        ''')

        conn.commit()
        print(f"数据库初始化成功，路径: {db_path}")
        return conn, cursor
    except Exception as e:
        raise RuntimeError(f"数据库初始化失败: {e}")

def close_database(conn):
    """
    关闭数据库连接。
    """
    conn.close()
file_reader.py中的内容：
import os
from word_manager import query_word

def read_txt_files(conn, cursor):
    """
    启动时检测并读取当前目录下的 .txt 文件中的单词，支持重复检查。
    仅处理文件名中包含 'word' 或 'Word' 关键词的文件。
    """
    print("\n=== 检测并读取 .txt 文件中的单词 ===")
    # 过滤文件名中包含 'word' 或 'Word' 的 .txt 文件
    txt_files = [f for f in os.listdir('.') if f.endswith('.txt') and ('word' in f.lower())]
    
    if not txt_files:
        print("当前目录下未找到文件名中包含 'word' 或 'Word' 的 .txt 文件。")
        return
    
    print(f"找到 {len(txt_files)} 个 .txt 文件：{', '.join(txt_files)}")
    total_words = 0
    added_words = 0
    
    for txt_file in txt_files:
        print(f"正在读取文件: {txt_file}")
        try:
            with open(txt_file, 'r', encoding='utf-8') as file:
                words = [line.strip() for line in file if line.strip()]
            print(f"文件 {txt_file} 中读取了 {len(words)} 个单词。")
            total_words += len(words)
            
            for word in words:
                cursor.execute("SELECT word FROM words WHERE word = ?", (word,))
                if cursor.fetchone():
                    print(f"单词 '{word}' 已存在，跳过添加。")
                    continue
                
                word_info = query_word(word, conn, cursor)
                if word_info:
                    print(f"单词 '{word}' 已成功添加到数据库。")
                    added_words += 1
                else:
                    print(f"查询单词 '{word}' 失败，仅保存单词到数据库。")
                    cursor.execute("""
                        INSERT INTO words (word, status) 
                        VALUES (?, '需复习')
                    """, (word,))
                    conn.commit()
                    added_words += 1
        except Exception as e:
            print(f"读取文件 {txt_file} 时出错: {e}")
    
    print(f"读取完成！共读取 {total_words} 个单词，成功添加到数据库 {added_words} 个。")

def detect_txt_files():
    """
    检测当前目录下是否有 .txt 文件，并显示文件列表和单词数量。
    仅显示文件名中包含 'word' 或 'Word' 关键词的文件。
    """
    print("\n=== 检测单词本文件 (.txt) ===")
    # 过滤文件名中包含 'word' 或 'Word' 的 .txt 文件
    txt_files = [f for f in os.listdir('.') if f.endswith('.txt') and ('word' in f.lower())]
    
    if not txt_files:
        print("当前目录下未找到文件名中包含 'word' 或 'Word' 的 .txt 文件。")
        return
    
    print(f"找到 {len(txt_files)} 个 .txt 文件：")
    for idx, txt_file in enumerate(txt_files, 1):
        try:
            with open(txt_file, 'r', encoding='utf-8') as file:
                words = [line.strip() for line in file if line.strip()]
            print(f"{idx}. {txt_file} - 包含 {len(words)} 个单词")
        except Exception as e:
            print(f"{idx}. {txt_file} - 读取错误: {e}")
recitation.py中的内容：
def recitation_mode(conn, cursor):
    """
    背诵模式，基于间隔重复（SM2 算法）显示需要复习的单词，并动态调整复习间隔。
    提供两种背诵方式：1. 显示英文并确认是否记住；2. 显示中文并输入英文。
    """
    print("\n=== 背诵模式（基于间隔重复） ===")
    print("请选择背诵方式：")
    print("1. 显示英文，确认是否记住")
    print("2. 显示中文，输入英文单词")
    choice = input("请输入选项 (1 或 2): ")
    
    # 查询所有单词，检查需要复习的单词（状态为“需复习”）
    cursor.execute("SELECT * FROM words WHERE status = '需复习'")
    all_words = cursor.fetchall()
    
    if not all_words:
        print("没有需要复习的单词！")
        return
    
    # 过滤需要复习的单词（这里简化处理，假设每次背诵从头开始，未来可基于累计计数或时间）
    words_to_review = all_words  # 暂不实现复杂的“间隔已到”逻辑，实际应用中可进一步筛选
    print(f"共有 {len(words_to_review)} 个单词需要复习。")
    
    for word_data in words_to_review:
        # 获取当前单词的间隔、复习次数和易度因子
        interval = word_data[6] if word_data[6] is not None else 0  # 字段索引需根据数据库调整
        repetitions = word_data[7] if word_data[7] is not None else 0
        easiness_factor = word_data[8] if word_data[8] is not None else 2.5
        
        if choice == '1':
            # 方式1：显示英文，确认是否记住
            print(f"\n单词: {word_data[1]}")
            input("按回车查看详细信息...")
            print(f"翻译: {word_data[2]}")
            print(f"音标: {word_data[3]}")
            print(f"例句: {word_data[4]}")
            
            # 询问用户是否记住，获取评分（简化版：y=4 表示记住，n=2 表示忘记）
            status = input("是否记住了？(y/n): ").lower()
            if status == 'y':
                quality = 4  # 表示记住
                print(f"单词 '{word_data[1]}' 已标记为 '已掌握'。")
            else:
                quality = 2  # 表示忘记
                print(f"单词 '{word_data[1]}' 仍标记为 '需复习'。")
        
        elif choice == '2':
            # 方式2：显示中文，要求输入英文
            print(f"\n中文翻译: {word_data[2]}")
            user_input = input("请输入英文单词 (输入 'q' 退出): ")
            
            if user_input.lower() == 'q':
                print("退出背诵模式。")
                break
                
            if user_input.lower() == word_data[1].lower():  # 不区分大小写比较
                quality = 4  # 表示记住
                print("正确！")
                print(f"单词: {word_data[1]}")
                print(f"音标: {word_data[3]}")
                print(f"例句: {word_data[4]}")
                print(f"单词 '{word_data[1]}' 已标记为 '已掌握'。")
            else:
                quality = 2  # 表示忘记
                print(f"错误！正确答案是: {word_data[1]}")
                print(f"音标: {word_data[3]}")
                print(f"例句: {word_data[4]}")
                print(f"单词 '{word_data[1]}' 仍标记为 '需复习'。")
        else:
            print("无效选项，返回默认方式（显示英文）。")
            choice = '1'
            continue
            
        # 根据 SM2 算法更新间隔、复习次数和易度因子
        if quality >= 3:  # 记住（答对）
            if repetitions == 0:
                interval = 1  # 第一次复习后间隔为1
            elif repetitions == 1:
                interval = 6  # 第二次复习后间隔为6
            else:
                interval = int(interval * easiness_factor)  # 后续间隔按易度因子增长
            repetitions += 1
            # 更新状态为“已掌握”（可选，也可以保持“需复习”直到达到一定复习次数）
            new_status = '已掌握' if repetitions >= 3 else '需复习'
        else:  # 忘记（答错）
            repetitions = 0  # 重置复习次数
            interval = 1  # 重置间隔为1
            new_status = '需复习'
        
        # 更新易度因子（答对增加，答错减少）
        easiness_factor = max(1.3, min(2.5, easiness_factor + 0.1 * (quality - 3)))
        
        # 更新数据库中的单词信息
        cursor.execute("""
            UPDATE words 
            SET status = ?, interval = ?, repetitions = ?, easiness_factor = ?
            WHERE word = ?
        """, (new_status, interval, repetitions, easiness_factor, word_data[1]))
        conn.commit()
        
        print(f"更新: 间隔={interval}, 复习次数={repetitions}, 易度因子={easiness_factor:.2f}")

    print("本次背诵结束！")
word_manager.py中的内容：
def query_word(word, conn, cursor):
    """
    查询单词，支持从数据库读取或在线查询并保存。
    返回单词信息，或在查询失败时返回 None。
    """
    cursor.execute("SELECT * FROM words WHERE word = ?", (word,))
    result = cursor.fetchone()
    if result:
        print(f"\n单词: {result[1]}")
        print(f"翻译: {result[2]}")
        print(f"音标: {result[3]}")
        print(f"例句: {result[4]}")
        print(f"状态: {result[5]}")
        return result
    else:
        from api import fetch_word_info
        print(f"单词 '{word}' 未在数据库中找到，正在查询在线信息...")
        word_info = fetch_word_info(word)
        if word_info:
            cursor.execute("""
                INSERT INTO words (word, translation, phonetic, example, status)
                VALUES (?, ?, ?, ?, '需复习')
            """, (word, word_info['translation'], word_info['phonetic'], word_info['example']))
            conn.commit()
            print(f"单词 '{word}' 已成功添加到数据库。")
            print(f"翻译: {word_info['translation']}")
            print(f"音标: {word_info['phonetic']}")
            print(f"例句: {word_info['example']}")
            print("状态: 需复习")
            return word_info
        else:
            return None

def view_words(cursor):
    """
    查看数据库中的所有单词列表。
    """
    print("\n=== 单词列表 ===")
    cursor.execute("SELECT * FROM words")
    words = cursor.fetchall()
    if not words:
        print("数据库中没有单词！")
        return
    for word in words:
        print(f"ID: {word[0]}, 单词: {word[1]}, 翻译: {word[2]}, 状态: {word[5]}")

def mark_word_status(conn, cursor):
    """
    标记单词状态（需复习/已掌握）。
    """
    print("\n=== 标记单词状态 ===")
    view_words(cursor)
    word_id = input("请输入要标记的单词 ID (或输入 '取消' 返回): ")
    if word_id.lower() == '取消':
        return
    try:
        word_id = int(word_id)
        cursor.execute("SELECT * FROM words WHERE id = ?", (word_id,))
        word = cursor.fetchone()
        if not word:
            print("无效的 ID！")
            return
        status = input(f"设置单词 '{word[1]}' 的状态为 (1: 需复习, 2: 已掌握): ")
        if status == '1':
            cursor.execute("UPDATE words SET status = '需复习' WHERE id = ?", (word_id,))
            print(f"单词 '{word[1]}' 已标记为 '需复习'。")
        elif status == '2':
            cursor.execute("UPDATE words SET status = '已掌握' WHERE id = ?", (word_id,))
            print(f"单词 '{word[1]}' 已标记为 '已掌握'。")
        else:
            print("无效选择！")
        conn.commit()
    except ValueError:
        print("请输入有效的 ID！")

def batch_add_words(conn, cursor):
    """
    批量手动输入单词，每行一个，支持重复检查。
    """
    print("\n=== 批量输入单词 ===")
    print("请输入单词（每行一个），直接按回车结束输入：")
    words = []
    while True:
        word = input().strip()
        if word == "":
            break
        if word:
            words.append(word)
    
    if not words:
        print("未输入任何单词！")
        return
    
    print(f"输入了 {len(words)} 个单词，正在查询并添加到数据库...")
    for word in words:
        cursor.execute("SELECT word FROM words WHERE word = ?", (word,))
        if cursor.fetchone():
            print(f"单词 '{word}' 已存在，跳过添加。")
            continue
        
        word_info = query_word(word, conn, cursor)
        if word_info:
            print(f"单词 '{word}' 已成功添加到数据库。")
        else:
            print(f"查询单词 '{word}' 失败，仅保存单词到数据库。")
            cursor.execute("""
                INSERT INTO words (word, status) 
                VALUES (?, '需复习')
            """, (word,))
            conn.commit()

    print("批量添加完成！")
